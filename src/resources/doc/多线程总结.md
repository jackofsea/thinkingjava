

# 多线程总结

## 一、线程基础

### 1.线程的创建

* 实现Runnable接口，这种方式最常用，代码耦合度低

```java
public class Animal implements Runnable{
    @Override
    public void run() {
       //TODO 
    }
}
```

启动线程:

```java
public class Boot{
    public static void main(String[] args) {
        Thread t=new Thread(new Animal());
        t.start();
    }
}
```



* 继承Thread类，重写run方法，不推荐，代码耦合度高

```java
public class Animal extends Thread{
    @Override
    public void run() {
       //TODO 
    }
}
```

启动线程：

```java
public class Boot{
    public static void main(String[] args) {
        Animal an=new Animal();
        an.start();
    }
}
```



* 实现Callable接口，有返回值，主要用于异步计算

```java
public class MatchCounter implements Callable<Integer> {
     @Override
    public Integer call() throws Exception {
         //TODO 
    }
}
```

启动线程：

```java
public class Boot{
    public static void main(String[] args) {
        MatchCounter counter = new MatchCounter();
        FutureTask<Integer> task = new FutureTask<>(counter);
        Thread t = new Thread(task);
        t.start();
    }
}
```

### 2.线程的重要接口

* ```java
  public synchronized void start()
  ```

线程启动方法，调用此方法将启动线程。

* ```java
   /**
       * Waits for this thread to die.
       *
       * <p> An invocation of this method behaves in exactly the same
       * way as the invocation
       *
       * <blockquote>
       * {@linkplain #join(long) join}{@code (0)}
       * </blockquote>
       *
       * @throws  InterruptedException
       *          if any thread has interrupted the current thread. The
       *          <i>interrupted status</i> of the current thread is
       *          cleared when this exception is thrown.
       */
  public final void join() 
  ```

等待调用此方法的线程结束，再继续执行本线程。

* ```java
  public static native void sleep(long millis)
  ```

线程睡眠，睡眠不释放锁。

* ```java
  public State getState() 
  ```

获得线程的状态，Java定义线程五中状态在Thread.State枚举类里：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING和TERMINATED。





设置线程的优先级

## 二、线程池

  主要讲ThreadPoolExecutor类，快速建立线程池可使用Executors类的方法快速建立，这里不做详细介绍。、

