

# 多线程总结

## 一、线程基础

### 1.1.线程的创建

* 实现Runnable接口，这种方式最常用，代码耦合度低

```java
public class Animal implements Runnable{
    @Override
    public void run() {
       //TODO 
    }
}
```

启动线程:

```java
public class Boot{
    public static void main(String[] args) {
        Thread t=new Thread(new Animal());
        t.start();
    }
}
```



* 继承Thread类，重写run方法，不推荐，代码耦合度高

```java
public class Animal extends Thread{
    @Override
    public void run() {
       //TODO 
    }
}
```

启动线程：

```java
public class Boot{
    public static void main(String[] args) {
        Animal an=new Animal();
        an.start();
    }
}
```



* 实现Callable接口，有返回值，主要用于异步计算

```java
public class MatchCounter implements Callable<Integer> {
     @Override
    public Integer call() throws Exception {
         //TODO 
    }
}
```

启动线程：

```java
public class Boot{
    public static void main(String[] args) {
        MatchCounter counter = new MatchCounter();
        FutureTask<Integer> task = new FutureTask<>(counter);
        Thread t = new Thread(task);
        t.start();
    }
}
```

### 2.2.线程的重要接口

线程启动方法，调用此方法将启动线程，底层调用start0函数，在操作系统中开启一个线程。

* ```java
  public synchronized void start()
  ```

等待调用此方法的线程结束，再继续执行本线程。

* ```java
   /**
       * Waits for this thread to die.
       *
       * <p> An invocation of this method behaves in exactly the same
       * way as the invocation
       *
       * <blockquote>
       * {@linkplain #join(long) join}{@code (0)}
       * </blockquote>
       *
       * @throws  InterruptedException
       *          if any thread has interrupted the current thread. The
       *          <i>interrupted status</i> of the current thread is
       *          cleared when this exception is thrown.
       */
  public final void join() 
  ```

线程睡眠，睡眠不释放锁。

* ```java
  public static native void sleep(long millis)
  ```

获得线程的状态，Java定义线程五中状态在Thread.State枚举类里：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING和TERMINATED。

* ```java
  public State getState() 
  ```

设置线程的优先级,线程优先级1-10，默认为5，由于操作系统的不同，设置线程优先级无法获得效率提升，所以不建议额外设置。

```java
public final void setPriority(int newPriority) 
```

停止线程

```java
//暴力停止，已被废弃 
public final void stop()
//把线程设置为中断状态，线程里面的一些函数能检测到中断并抛出异常如sleep
public void interrupt()
  //返回线程是否中断，并清除中断标志
 public static boolean interrupted()
  //返回线程是否中断，不清除中断标志
public boolean isInterrupted()
```



### 2.3.线程的状态

线程在运行过程中会有不同的状态，标准的模型有以下两种。 

**三态模型**

  进程的三种状态之间的转化指的是就绪态、运行态和阻塞态之间的转化。从理论上分析有4可能的情况，如下：

① 就绪态>>运行态：其他进程时间片用完，CPU调度选中一个就绪进程执行；

② 运行态>>就绪态：分配给每个进程的时间片是有限的，运行时间片到了或出现更高优先权进程就进入到就绪态；

③ 运行态 >>阻塞态：正在执行的进程因发生某种等待事件而无法执行，如发生了I/O请求，此时由运行态转换到阻塞态；

④ 阻塞态>>就绪态：进程所等待的事件已经发生，进程进入就绪队列。

![](..\imgs\mutilThread-6.png)

**五态模型**

在五态模型中，进程分为新建态(new)、就绪态(ready)、运行态(running)、阻塞态(waiting)、终止态(terminated)。

新建态：进程在创建时需要申请一个空白进程管理块，向其中填写控制和管理进程的信息，完成资源分配；

就绪态：进程已经准备好，已经分配到所需资源，只要分配到CPU就能够立刻运行；

运行态：进程处于就绪状态被调度后，进入运行态；

阻塞态：正在执行的进程由于某些某些事件（如I/O调用）而无法运行，进程受到阻塞；

终止态：进程结束，或出现错误，或被系统终止，进入终止状态。

![](..\imgs\mutilThread-7.png)

java定义了六种状态，如下：

1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. 阻塞(BLOCKED)：表示线程阻塞于锁。
4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕。

### 2.4.锁

java中锁的实现分为两种，一种是以synchronized关键字为主，另一种手以Lock接口为主的所有实现类及相关类。

**synchronized**

1.synchronized可以写在实例方法上，表示锁住当前对象；

2.synchronized可以写在静态方法上，表示锁住类对象；

3.synchronized可以锁主代码块；

4.synchronized是自动解锁的。

这种关键字实现的锁JVM内部帮我优化出了三种锁：偏向锁，轻量级和重量级锁，锁有一个升级的过程，锁标志存在对象头信息中，如图：

锁在程序运行的过程中，有一个升级的过程：

a.当一个线程访问时，此时是偏向锁（偏向锁在并发不大的时候效率高）；

b.当两个线程交替访问互斥代码时或者通过一定次数的自旋（CAS）获得锁时，偏向锁升级为轻量级锁；

c.系统竞争异常大，轻量级锁升级为重量级锁

单个偏向锁时不可重新偏向，但是sun JVM对同一类的对象（20个以上）有批量重定向的优化。

**Lock**

Lock实现类及相关类

1.ReadLock，读锁

2.WriteLock，写锁

3.ReentrantLock,可重入锁

4.LockSupport，锁的基本类

5.ReentrantReadWriteLock

6.StampedLock

### 2.5.同步

java中的同步使用锁或者无锁（CAS相关的类）。

### 2.6.线程并发规则

**内存可见性：**JVM中线程执行有两部分内存：工作内存和主存，工作内存是线程私有，存储变量（有主存中读取过来的），作为缓存存储变量副本，主存是所有线程能访问的。当变量在线程工作内存中发生变化，其他线程感受不到此变量的变化，除非变量的改变刷新到主存，其他线程才能读到最新的值，但其中存在延迟，所有不能确定变量值是否最新。因此，线程对变量操作是在工作内存中，其他线程不可见。

**重排序：**一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。java存在编译器重排序，处理器重排序（指令级、内存系统）等情况，重排序可能会导致多线程程序出现内存可见性问题。

**单线程遵守as-if-serial语义：**不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。 

**多线程遵守happens-before原则：**在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 

2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照 happens-before关系来执行的结果一致，那么这种重排序并不非法。 下面是happens-before原则规则： 

    a.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 

    b.锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作； 

    c.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 

    d.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C； 

     e.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作； 

     f.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 

     g.线程join规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行； 

     h.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始； 我们来详细看看上面每条规则（摘自《深入理解Java虚拟机第12章》）：

 程序次序规则：一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对单线程有效，在多线程环境下无法保证正确性。 

锁定规则：这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。 

volatile变量规则：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。 

传递规则：提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C 

线程启动规则：假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。

 线程join规则：假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。 

## 二、线程池

  主要讲ThreadPoolExecutor类，快速建立线程池可使用Executors类的方法快速建立，这里不做详细介绍。

主要的类图如下：

![](..\imgs\Executor.png)

**Executor**：顶级接口，只有一个execute方法，作用是执行线程任务。

**ExecutorService:**线程池的核心功能接口，提供方法如：submit、doInvokeAny，invokeAll等。

**AbstractExecutorService：**线程池骨干抽象实现，核心功能实现如submit，doInvokeAny，invokeAll等。

**ThreadPoolExecutor：**线程池核心实现类，实现线程池的细节

**线程执行流程：**

![](..\imgs\mutilThread-5.png)

核心线程是不会被销毁的，除非把**allowCoreThreadTimeOut**设置为true

### 2.1. 线程池的创建

```java
ExecutorService pool=new ThreadPoolExecutor(1,1,60L,TimeUnit.SECONDS,new ArrayBlockingQueue<>(100));
```

也可以使用工具类Executors快速创建，但是不推荐这么做，因为该工具类创建单线程（newSingleThreadExecutor）和固定线程（newFixedThreadPool）的时候都使用的无界队列(LinkedBlockingQueue)，这种做法不安全，可能会造成内存溢出。代码如下：

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {    
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),  threadFactory);
}
```



```java
public static ExecutorService newSingleThreadExecutor() {    
     return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L,                    TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));
}
```

构造函数：

```java
public ThreadPoolExecutor(int corePoolSize,  
                          int maximumPoolSize, 
                          long keepAliveTime,   
                          TimeUnit unit, 
                          BlockingQueue<Runnable> workQueue,                                                       ThreadFactory threadFactory)
```

**corePoolSize:**核心线程数，线程池内常驻线程数量；

**maximumPoolSize：**最大线程数量，线程池内支持最大执行线程数量；

**keepAliveTime：**空闲时间，当有非核心线程空闲的时间超过此时间时，这个非核心线程就会被结束；

**unit：**活动时间的单位,如TimeUnit.SECONDS，TimeUnit.SECONDS，TimeUnit.MILLISECONDS；

**workQueue：**任务队列，暂存任务；

**ThreadFactory:**线程工厂，如线程名字，线程组，线程优先级（基本没用）等；

### 2.2.线程池的流程

**线程池的线程数量M增长：**

   当线程池里的活动线程数量M < corePoolSize时， 线程池里的常驻线程数量等于M；

   当线程池里的活动线程数量M >= corePoolSize 且 M <= maximumPoolSize,任务不繁忙时的线程池常驻线程数量等于corePoolSize ，繁忙时的活动线程数量最大等于maximumPoolSize。

**线程池的任务提交顺序：**

​      新任务先提交给核心线程--》核心线程满后任务提交到工作队列---》工作队列满后任务提交到非核心线程

![](..\imgs\mutilThread-2.png)

**线程池的任务执行顺序：**

​     先满足核心线程执行任务--》当核心线程全无空闲，再让非核心线程执行任务--》最后再执行任务队列里面的任务

![](..\imgs\mutilThread-3.png)

当活动线程数量达到最大值，且队列已满，线程池跑出拒绝异常RejectedExecutionException

**线程池的四种拒绝策略：**

 ![](..\imgs\mutilThread-4.png)

AbortPolicy:**默认策略**，丢弃任务并抛出RejectedExecutionException

CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是任务提交线程的性能极有可能会急剧下降。

DiscardOldestPolicy：丢弃队列中最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。

DiscardPolicy：丢弃任务，不做任何处理。

**线程回收和复用**：

runWorker方法里的getTask()方法和processWorkerExit（）方法共同构成了非核心线程的回收功能；

runWorker方法里的getTask()实现线程的复用功能；

**线程池的关闭 ：**

ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：

shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务

shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务

**动态修改参数：**

修改核心线程：

```java
/**
     * Sets the core number of threads.  This overrides any value set
     * in the constructor.  If the new value is smaller than the
     * current value, excess existing threads will be terminated when
     * they next become idle.  If larger, new threads will, if needed,
     * be started to execute any queued tasks.
     *
     * @param corePoolSize the new core size
     * @throws IllegalArgumentException if {@code corePoolSize < 0}
     * @see #getCorePoolSize
     */
    public void setCorePoolSize(int corePoolSize) {
        if (corePoolSize < 0)
            throw new IllegalArgumentException();
        int delta = corePoolSize - this.corePoolSize;
        this.corePoolSize = corePoolSize;
        if (workerCountOf(ctl.get()) > corePoolSize)
            interruptIdleWorkers();
        else if (delta > 0) {
            // We don't really know how many new threads are "needed".
            // As a heuristic, prestart enough new workers (up to new
            // core size) to handle the current number of tasks in
            // queue, but stop if queue becomes empty while doing so.
            int k = Math.min(delta, workQueue.size());
            while (k-- > 0 && addWorker(null, true)) {
                if (workQueue.isEmpty())
                    break;
            }
        }
    }
```

设置最大线程数：

```java
 /**
     * Sets the maximum allowed number of threads. This overrides any
     * value set in the constructor. If the new value is smaller than
     * the current value, excess existing threads will be
     * terminated when they next become idle.
     *
     * @param maximumPoolSize the new maximum
     * @throws IllegalArgumentException if the new maximum is
     *         less than or equal to zero, or
     *         less than the {@linkplain #getCorePoolSize core pool size}
     * @see #getMaximumPoolSize
     */
    public void setMaximumPoolSize(int maximumPoolSize) {
        if (maximumPoolSize <= 0 || maximumPoolSize < corePoolSize)
            throw new IllegalArgumentException();
        this.maximumPoolSize = maximumPoolSize;
        if (workerCountOf(ctl.get()) > maximumPoolSize)
            interruptIdleWorkers();
    }
```

如果想要动态修改缓存队列的大小，需要自己实现一个阻塞队列，注意线程并发安全问题。

**线程预热：**

预热一个核心线程：

```java
 /** * Starts a core thread, causing it to idly wait for work. This 
 * overrides the default policy of starting core threads only when 
 * new tasks are executed. This method will return {@code false} 
 * if all core threads have already been started. 
 * * @return {@code true} if a thread was started 
 */
 public boolean prestartCoreThread() {    
     return workerCountOf(ctl.get()) < corePoolSize && addWorker(null, true);
 }
```

预热全部核心线程：

```java
/**
     * Starts all core threads, causing them to idly wait for work. This
     * overrides the default policy of starting core threads only when
     * new tasks are executed.
     *
     * @return the number of threads started
     */
    public int prestartAllCoreThreads() {
        int n = 0;
        while (addWorker(null, true))
            ++n;
        return n;
    }
```

**常见的四种线程池：**

利用Executors工具类可以快速创建四种线程池：

1.FixedThreadPool

2.SingleThreadExecutor

3.CachedThreadPool

4.ScheduledThreadPool

### 2.3.线程池调优

**通用的：**

IO密集型：通用的2N

CPU密集型：通用的N+1

## 三、并发工具

java中并发工具主要在java.util.concurrent包下，包括各种Lock类，Atomic类，线程和各类容器等。

**ArrayBlockingQueue：**底层以数组实现的阻塞队列

**LinkedBlockingQueue：**底层以链表实现的阻塞队列

**LinkedTransferQueue：**底层以链表实现的阻塞队列，和**LinkedBlockingQueue**主要区别是新增几个transfer()的API，目的是放入元素直接给到消费者，否则等待。

**DelayQueue：**延迟队列，可以用来实现定时任务调度

**CopyOnWriteArrayList：**写时复制List
CopyOnWriteArraySet

## 线程原理

3.1.线程创建原理

3.2.线程执行原理